options {
  STATIC=false;
  JAVA_UNICODE_ESCAPE=true;
}

PARSER_BEGIN(QueryParser)

package no.schibstedsok.front.searchportal.query.parser;

import java.io.StringReader;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class QueryParser {
    private Clause prevClause, currClause;
    private static final Log LOG = LogFactory.getLog(QueryParser.class);
}

PARSER_END(QueryParser)

/** Skip these characters, they are considered "white space" **/
SKIP : {
	","
	| "#"
    | " "
    | "\t"
    | "\r"
    | "\n"
}

TOKEN : {
/** Find operators first **/
  /**<OPERATOR: ".* "(<AND>|<OR>|<NOT>|<ANDNOT>)" .*">**/
  <AND: "AND">
| <OR: "OR">
| <NOT: "NOT">
| <ANDNOT: "ANDNOT">
/** then leaves **/
| <INTEGER: ((<DIGIT>)+)>
| <WORD: ((<LETTER>|<DIGIT>)+)>
| <QUOTED_WORD: "\"" (<WORD>|(" ")+)* "\"">
| <#LETTER:
/** UNICODE Characters **/
    [
        "\u0041"-"\u005a",
        "\u0061"-"\u007a",
        "\u00c0"-"\u00d6",
        "\u00d8"-"\u00f6",
        "\u00f8"-"\u00ff",
        "\u0100"-"\u1fff"
    ]
    >
| < #DIGIT:                                       // unicode digits
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

Clause parse() : 
{ 
  AllClause clauses = new AllClause();
  Clause clause;
}
{
    (
        /** [TODO] impl keyword **/
        (clause = clause()) {clauses.addClause(clause);}
    )*
    {return clauses;}
}

Clause clause() : 
{ 
  Clause clause;
}
{
    
    LOOKAHEAD(operation())(clause = operation()) {return clause;}
   |(clause = leaf())  {return clause;}
}

Clause operation() :
{
    LeafClause left;
    Clause right;
}
{
    LOOKAHEAD(2)
        ((left = leaf())<AND>(right = clause())) { return new AndClause(left,right);}

    | 
    LOOKAHEAD(2) 
        ((left = leaf())<OR>(right = clause())) { return new OrClause(left,right);}

    | 
    (<NOT>(right = leaf())) { return new NotClause(right);}

    | 
    LOOKAHEAD(2)
        ((left = leaf())<ANDNOT>(right = clause())) { return new AndNotClause(left,right);}
} 

LeafClause leaf() :
{
}
{
  (<WORD>) { return new WordClause(token.image); }
| (<INTEGER>) { return new IntegerClause(token.image); }
| (<QUOTED_WORD>) { return new PhraseClause(token.image.replaceAll("\"","")); }
}