/** Copyright (2005-2006) Schibsted SÃ¸k AS **/
options {
  STATIC=false;
  JAVA_UNICODE_ESCAPE=true;
}

PARSER_BEGIN(QueryParserImpl)

package no.schibstedsok.front.searchportal.query.parser;

import java.io.StringReader;
import java.util.List;
import java.util.ArrayList;
import no.schibstedsok.front.searchportal.query.*;
import no.schibstedsok.front.searchportal.query.token.TokenEvaluatorFactory;

/** This class is NOT synchronized. You must use a separate instance for each query. 
 *
 * @todo the LOOKAHEAD's can be reduced to one. but how?...
 **/
public final class QueryParserImpl extends AbstractQueryParser{

    public QueryParserImpl(final Context cxt){
        this(new StringReader(cxt.getQueryString()));
        context = cxt;
    }
}

PARSER_END(QueryParserImpl)

/** Skip these characters, they are considered "white space" **/
SKIP : {
    ","
    | "."    
    | "#"
    | " "
    | "\t"
    | "\r"
    | "\n"
}

TOKEN : {
/** Find operators first **/
  <AND: ("AND"|"+")>
| <OR:  ("OR"|"|")>
| <NOT: "NOT">              // choosing to identify "-" as the ANDNOT operator instead of the NOT operator.
| <ANDNOT: ("ANDNOT"|"-")>
/** then leaves **/
| <PHONE_NUMBER: (("+"|"00")"47"(" ")*){0,1}(<DIGIT>(" "){0,1}){8}>
| <ORGANISATION_NUMBER: (<DIGIT>){9}>
| <INTEGER: ((<DIGIT>)+)>
| <WORD: ((<LETTER>|<DIGIT>)+)>
| <QUOTED_WORD: "\"" (<WORD>|(" ")+)* "\"">
| <#LETTER:
/** UNICODE Characters **/
    [
        "\u0041"-"\u005a",
        "\u0061"-"\u007a",
        "\u00c0"-"\u00d6",
        "\u00d8"-"\u00f6",
        "\u00f8"-"\u00ff",
        "\u0100"-"\u1fff"
    ]
    >
| < #DIGIT:                                       // unicode digits
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

Clause parse() : 
{ 
  Clause clause;
  LOG.info("parsing: "+context.getQueryString());
}
{
        (clause = clause()) {return clause;}
}

Clause clause() : 
{ 
  Clause clause;
  LOG.trace("clause()");
}
{
    LOOKAHEAD(3)
    (clause = rootPrecedence()) {return clause;}
    | 
    (clause = leaf()) { return clause; }
}

/** PRECEDENCES **/

Clause rootPrecedence() :
{
    Clause clause;
    LOG.trace("rootPrecedence()");
}
{
    (clause = noPrecedence()) { return clause; }
}

Clause noPrecedence() :
{
    Clause clause;
    LOG.trace("noPrecedence()");
}
{
    LOOKAHEAD(3)
    (clause = looseJoinPrecedence()) { return clause; }
    |
    (clause = hiddenOrOperation()) { return clause; }
}

Clause looseJoinPrecedence() :
{
    Clause clause;
    LOG.trace("looseJoinPrecedence()");
}
{
    LOOKAHEAD(3)
    (clause = strongJoinPrecedence()) { return clause; }
    |
    (clause = orOperation()) { return clause; }    
}

Clause strongJoinPrecedence() :
{
    Clause clause;
    LOG.trace("strongJoinPrecedence()");
}
{
    LOOKAHEAD(3)
    (clause = prefixPrecedence()) { return clause; }
    |
    (clause = andOperation()) { return clause; }

}

Clause prefixPrecedence() :
{
    Clause clause;
    LOG.trace("prefixPrecedence()");
}
{
    (clause = notOperation()) { return clause; }
    |
    (clause = andNotOperation()) { return clause; }
}

/** OPERATIONS **/


NotClause notOperation() :
{
    Clause left;
    LOG.trace("notOperation()");
}
{
        (<NOT>(left = leaf()))  { return context.createNotClause(left); }
}

AndClause andOperation() :
{
    Clause left,right;
    LOG.trace("andOperation()");
}
{
        ((left = prefixPrecedence())<AND>(right = clause())) { return context.createAndClause(left,right); }
        |
        ((left = leaf())<AND>(right = clause())) { return context.createAndClause(left,right); }
}

OrClause orOperation() :
{
    Clause left,right;
    LOG.trace("orOperation()");
}
{
    LOOKAHEAD(3)
    ((left = strongJoinPrecedence())<OR>(right = clause())) { return context.createOrClause(left,right); }
    |
    ((left = leaf())<OR>(right = clause())) { return context.createOrClause(left,right); }
}

AndNotClause andNotOperation() :
{
    Clause left,right;
    LOG.trace("andNotOperation()");
}
{
        //((left = andPrecedence())<ANDNOT>(right = clause())) { return context.createAndNotClause(left,right); }
        (<ANDNOT>(left = clause())) { return context.createAndNotClause(left,null); }
} 

OrClause hiddenOrOperation() :
{
    Clause left,right;
    LOG.trace("hiddenOrOperation()");
}
{
    LOOKAHEAD(3)
    ((left = looseJoinPrecedence())(right = clause())) { return context.createOrClause(left,right); }
    |
    ((left = leaf())(right = clause())) { return context.createOrClause(left,right); }
} 

/** LEAVES **/

Clause leaf() :
{
    Token field = null;
    Clause clause = null;
    LOG.trace("leaf()");
}
{
    LOOKAHEAD(2)
    (field=<WORD>":")(clause = fieldedLeaf(field)) {return clause;}
    |
    (clause = fieldedLeaf(null)) {return clause;}
}
    

Clause fieldedLeaf(final Token field) :
{
    LOG.trace("fieldedLeaf()");
}
{
    (<PHONE_NUMBER>) 
            { 
                // Create a "Possibility" OrClause
                // it might not be a phone number... // XXX Could this be done with parser logic...
                
                final PhoneNumberClause phClause = context.createPhoneNumberClause(token.image, field == null ? null : field.image);
                if( token.image.indexOf("+") >=0 || token.image.indexOf(" ")<0 ){ 
                    // it's definitely a phone number
                    return phClause;
                }else{
                    Clause prevClause = null;
                    final String[] numbers = token.image.split(" ");
                    for(int i = 0; i < numbers.length; ++i){
                        final String number = numbers[i];
                        final LeafClause leafClause = number.indexOf("+") <0
                                ? (LeafClause)context.createIntegerClause(number, field == null ? null : field.image)
                                : (LeafClause)context.createWordClause(number, field == null ? null : field.image);
                        if( prevClause != null ){
                            final OrClause orClause = context.createOrClause(leafClause,prevClause);
                            prevClause = orClause;
                        }else{
                            prevClause = leafClause;
                        }
                    }
                    return context.createOrClause(phClause, prevClause);
                }
            }
    | 
    (<ORGANISATION_NUMBER>) 
            { 
                // Create a a "Possibility" OrClause
                // it might not be a Organisation number... // XXX Could this be done with parser logic...
                
                final OrganisationNumberClause orgClause = context.createOrganisationNumberClause(token.image, field == null ? null : field.image);
                
                Clause prevClause = null;
                final String[] numbers = token.image.split(" ");
                for(int i = 0; i < numbers.length; ++i){
                    final String number = numbers[i];
                    final IntegerClause intClause = context.createIntegerClause(number, field == null ? null : field.image);
                    if( prevClause != null ){
                        final OrClause orClause = context.createOrClause(intClause, prevClause);
                        prevClause = orClause;
                    }else{
                        prevClause = intClause;
                    }
                }
                return context.createOrClause(orgClause, prevClause);
            }
    |
    <WORD>
        { 
            return context.createWordClause( token.image, field == null ? null : field.image );
        }
    | 
    <INTEGER>
        { 
            return context.createIntegerClause( token.image, field == null ? null : field.image );
        }
    | 
    <QUOTED_WORD>
        { 
            return context.createPhraseClause( token.image, field == null ? null : field.image );
        }

}
